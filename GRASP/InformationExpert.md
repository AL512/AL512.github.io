---
layout: default
title: Information Expert - Мозг вашей системы
parent: GRASP
nav_order: 1
---
# Information Expert - Мозг вашей системы

*Где живет логика? Почему данные должны управлять поведением?*

Представьте библиотеку. Кто лучше всех знает, где найти конкретную книгу? Библиотекарь? Или... сама книга? Абсурд! Логично спросить у того, *кто владеет информацией* – у каталога или библиотекаря. Так и в коде. **Information Expert** отвечает на главный вопрос: "Кому *по праву* принадлежит эта ответственность?". Это первый и самый естественный принцип распределения обязанностей: **отдайте задачу тому объекту, который обладает максимумом необходимых для ее выполнения данных**. Перестаньте тыкать методы куда попало! Давайте разберемся, почему "данные диктуют поведение" – это не ограничение, а освобождение от хаоса, и как найти истинного "мозга" для каждой операции в вашем коде.


**Суть принципа:**
Назначайте ответственность за выполнение операции тому классу, который обладает **максимумом информации**, необходимой для её реализации. 

## Почему это "Мозг"?

Представьте, что ваш код – это организация. Кто должен принимать решения? Тот, у кого есть **вся необходимая информация** для принятия *обоснованного* решения. Не менеджер из другого отдела, не случайный сотрудник, а именно **эксперт в данной конкретной области**. Information Expert формализует этот здравый смысл в ООП.


## Как это работает на практике



1. **Задайте Вопрос:** "Какая информация (поля, свойства) нужна для выполнения этой задачи?"
2. **Найдите Владельца:** Определите класс, который уже содержит большую часть (или всю) эту информацию. Это и есть **Expert**.
3. **Назначьте Метод:** Поместите метод, реализующий задачу, прямо в этот класс.


## Почему "Данные Должны Управлять Поведением"?

Это естественное следствие принципа:

1. **Инкапсуляция:** Класс, владеющий данными, может безопасно и эффективно манипулировать ими. Не нужно "вытаскивать" данные наружу для обработки где-то еще, нарушая инкапсуляцию.
2. **Снижение Связанности (Low Coupling):** Если метод работает с данными внутри своего класса, ему не нужно знать о других классах (кроме, возможно, своих непосредственных компонентов). Это уменьшает количество связей между классами.
3. **Повышение Логической Связности (High Cohesion):** Класс, содержащий и данные, и методы для их обработки, становится более целостным и сфокусированным на своей основной задаче.
4. **Упрощение Поиска Логики:** Где искать код, рассчитывающий итог заказа? Естественно, в классе Order, а не в каком-нибудь OrderCalculatorHelper или, что хуже, прямо в контроллере API.
5. **Упрощение Модификации:** Изменения в структуре данных обычно требуют изменений в логике их обработки. Если они находятся в одном классе, это проще и безопаснее.

## Типичные Антипаттерны (Как "Стреляем Себе в Ногу")

### 1. Типичные Антипаттерны (Как "Стреляем Себе в Ногу")

```csharp
// ПЛОХО: Логика расчета цены вырвана из класса OrderItem
public static class PriceCalculator
{
    public static decimal CalculateTotalPrice(Order order)
    {
        decimal total = 0;
        foreach (var item in order.Items)
        {
            // Доступ к приватным данным? Или публичным, но все равно не там!
            total += item.Quantity * item.Product.Price; 
        }
        // ... возможные скидки на сам заказ, которые тоже лежат в order?
        return total;
    }
}
```

**Проблема:** Класс PriceCalculator становится "мусоркой" для любой ценовой логики. Он должен знать внутреннюю структуру Order и OrderItem. При изменении структуры заказа (добавлении скидок на уровень позиции, например) меняться будет код вне этих классов. Нарушение инкапсуляции, высокий риск ошибок.


### 2. "Контроллер-Бог" (Fat Controller)

```csharp
// ПЛОХО: Контроллер берет на себя роль эксперта
[ApiController]
public class OrderController : ControllerBase
{
    [HttpPost("calculateTotal")]
    public ActionResult<decimal> CalculateTotal([FromBody] Order order)
    {
        // ... та же самая логика расчета, что и в плохом PriceCalculator, прямо здесь!
        decimal total = 0;
        foreach (var item in order.Items)
        {
            total += item.Quantity * item.Product.Price;
        }
        return total;
    }
}
```

**Проблема:** Бизнес-логика зашита в слой представления/API. Невозможно переиспользовать, сложно тестировать изолированно, контроллер превращается в монстра.


### 3. "Чрезмерное Распыление" (Logic Spread Thin)

- Логика проверки валидности email раскидана по 10 разным местам в коде.
- Правила применения скидки дублируются в сервисе заказов и в сервисе корзины.

**Проблема:** Нарушение DRY, сложность поддержки и согласованности изменений.

## Исправляем Ошибки с Information Expert 

### 1. Правильный Расчет Цены Заказа:

```csharp
public class OrderItem
{
    public Product Product { get; set; }
    public int Quantity { get; set; }

    // Эксперт для расчета стоимости позиции: у него есть и Product.Price, и Quantity!
    public decimal CalculateLineTotal()
    {
        return Quantity * Product.Price;
    }
}

public class Order
{
    public List<OrderItem> Items { get; set; } = new List<OrderItem>();
    public decimal Discount { get; set; } // Информация о скидке на весь заказ - здесь!

    // Эксперт для расчета ИТОГО по заказу: у него есть все Items и Discount!
    public decimal CalculateOrderTotal()
    {
        decimal subtotal = 0;
        foreach (var item in Items)
        {
            subtotal += item.CalculateLineTotal(); // Делегируем расчет позиции ее эксперту!
        }
        return subtotal * (1 - Discount); // Применяем скидку, информацию о которой имеем здесь
    }
}
```

- OrderItem знает, как считать свою стоимость (у него есть Product.Price и Quantity).
- Order знает, как считать общую сумму (у него есть все Items и Discount). Он делегирует подсчет суммы каждой позиции ее эксперту (item.CalculateLineTotal()).
- Контроллер или сервис теперь вызывает просто order.CalculateOrderTotal() – чисто, понятно, инкапсулировано.

### 2. Проверка Валидности Объекта

```csharp
public class User
{
    public string Email { get; set; }
    public DateTime BirthDate { get; set; }

    // Эксперт для проверки валидности ПОЛЬЗОВАТЕЛЯ: у него есть Email и BirthDate!
    public bool IsValid()
    {
        return IsEmailValid(Email) && IsAdult(BirthDate);
    }

    private bool IsEmailValid(string email) { ... } // Приватные методы-помощники, использующие данные User
    private bool IsAdult(DateTime birthDate) { ... }
}
```

Логика валидации принадлежит данным, которые она валидирует. Изменение правил валидации email или возраста происходит только в одном месте – внутри класса User.

## Когда Expert НЕ Применять Слепо (Границы Принципа)

1. **Нарушение SRP (Single Responsibility Principle):** Если добавление метода эксперта делает класс слишком большим и отвечающим за много несвязанных вещей, это сигнал. Возможно, данные нужно перегруппировать или вынести часть ответственности в Pure Fabrication (например, сложный отчет).
2. **Создание Нежелательных Зависимостей:** Если для выполнения задачи Expert'у нужно много информации из разных, слабосвязанных частей системы, назначение ему ответственности может создать сильную связь (High Coupling) между этими частями. Тут может помочь паттерн Посредник (Mediator) или вынесение логики в отдельный сервис (Pure Fabrication).
3. **Потребность в Координации:** Если задача требует взаимодействия нескольких независимых экспертов, ответственность за координацию этой задачи нужно назначить отдельному классу (см. принцип Controller в GRASP или паттерн Фасад).

## Как Найти Information Expert в Коде (Алгоритм "Детектива")

1. **Определите Конкретную Задачу:** Что именно нужно сделать? (Рассчитать сумму, проверить валидность, отфильтровать список, сгенерировать отчет).
2. **Выявите Необходимые Данные:** Какие свойства, поля, ассоциации (ссылки на другие объекты) нужны для решения задачи? Составьте список.
3. **Ищите "Владельца":** Пройдитесь по списку данных. Какой класс "владеет" большинством из них? Какой класс является естественным контейнером для этих данных? Этот класс – главный кандидат в Эксперты.
4. **Проверьте "Право Собственности":** Имеет ли этот класс логическое право на выполнение этой задачи? Не нарушает ли это его основную ответственность? Не создаст ли это сильных зависимостей?
5. **Делегируйте:** Если задача требует данных, разбросанных по иерархии (как в примере с Order и OrderItem), главный эксперт (Order) делегирует подзадачи своим "подэкспертам" (OrderItem).

## Преимущества следования принципу

**Преимущества:**
1. **Упрощение рефакторинга:** Изменения затрагивают только один класс.
2. **Повышение тестируемости:** Легко тестировать изолированную логику.
3. **Улучшение читаемости:** Логика находится там, где её ожидаешь найти.
4. **Естественная модульность:** Классы становятся самодостаточными.
5. **Устойчивость к изменениям:** Меньше вероятность "эффекта домино".


## Почему Information Expert - Фундамент?

1. **Это Естественно:** Это самый интуитивный и логичный способ распределения обязанностей в ООП. "У кого данные – тот и отвечает".
2. **Это Основа Инкапсуляции:** Хранить данные и методы их обработки вместе – суть инкапсуляции.
3. **Это Защита от Хаоса:** Предотвращает появление "божественных объектов", "статических помоек" и размазывание логики.
4. **Это Путь к Качеству:** Ведущий к Low Coupling, High Cohesion, тестируемости и сопровождаемости.

**Золотое правило:** Если классу для выполнения операции приходится постоянно запрашивать данные у других объектов - вероятно, ответственность назначена не тому классу.

## Заключение

**Information Expert** - зто не просто шаблон, это базовый закон поддержания порядка в вашем коде. Это не догма, а компас. Он не отменяет других принципов (как SRP или необходимость Pure Fabrication), но дает первый и самый важный ориентир. 

1. **Данные Диктуют Поведение:** Это не тирания, а здравый смысл. Класс, обладающий информацией, – лучший кандидат для её обработки. Перестаньте вытаскивать данные наружу и пинать их статическими методами из далека.
2. **Инкапсуляция – Ваш Щит:** Хранение данных и методов их обработки в одном месте – суть инкапсуляции. Это защищает целостность объекта и скрывает сложность от внешнего мира.
3. **Expert Предотвращенный "Выстрел в Ногу":** Каждый раз, назначая ответственность истинному эксперту, Вы:
- **Убиваете дублирование:** Логика живет в одном предсказуемом месте.
- **Рубите "божественные объекты" на корню:** Контроллеры и утилиты перестают быть свалками логики.
- **Строите основу для Low Coupling:** Классы меньше знают друг о друге, связи проще.
- **Повышаете Cohesion:** Классы становятся более сфокусированными и понятными.
- **Делаете код тестируемым:** Легко проверить логику, которая живет внутри одного класса.