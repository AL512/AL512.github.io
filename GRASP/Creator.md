---
layout: default
title: Creator - Контролируемый хаос порождения объектов
parent: GRASP
nav_order: 2
---
# Creator - Контролируемый хаос порождения объектов

*Кому позволить создавать экземпляры? Как избежать "подпольных фабрик"?*

Объекты не падают с неба. Их кто-то должен создавать. Но кто? Тот, кто кричит громче всех? Или может, DI-контейнер – наш всемогущий спаситель? Стоп! **Creator** – это про *архитектурную целесообразность*, а не про техническую возможность. Этот принцип задает правила "родительства" в ООП: **объект А должен создавать объект Б, если А содержит, агрегирует, записывает или активно использует Б, или обладает данными для инициализации Б**. Нарушение этих правил ведет к "подпольным фабрикам" – хаотичному созданию объектов где угодно, что ломает инкапсуляцию и усложняет понимание зависимостей. Узнайте, как укротить хаос рождения объектов в C# и перестать прятать new в неожиданных местах.

**Суть принципа:**
Назначьте ответственность за создание экземпляров класса Б классу A, если выполняется одно или несколько из условий:
1. А содержит или композитно владеет Б (часть целого).
2. А агрегирует Б (имеет коллекцию Б).
3. А активно использует Б (Б — ключевая зависимость А).
4. А обладает данными, необходимыми для инициализации Б (знает, как создать Б).
5. А записывает/сохраняет экземпляры Б.

## Почему "Контролируемый Хаос"?

Создание объектов (new) кажется простым. Но где это делать — определяет будущую сложность системы. Бесконтрольное создание объектов где угодно (хаос) приводит к:
- **Нарушению Инкапсуляции:** Классы начинают лезть во внутренности других классов, чтобы их создать.
- **Высокой Связанности (High Coupling):** Класс X жестко зависит от конкретной реализации Y, которую он создает.
- **"Подпольным Фабрикам":** Появлению Helper.CreateY(), YFactory в случайных местах, маскирующих истинные зависимости.
- **Трудностям Тестирования:** Невозможности подменить зависимость (например, на mock) из-за жесткого связывания через new.

**Creator вводит правила "родительства"**, основанные **на сильной семантической связи** между создающим (A) и создаваемым (Б). Это делает зависимости предсказуемыми и локализованными.

## 1. Антипаттерн: "Подпольная Фабрика" / Случайный new

```csharp
public class OrderProcessor
{
    public void Process(Order order)
    {
        // ПЛОХО: OrderProcessor создает Logger сам. Почему он? Где связь?
        var logger = new FileLogger("log.txt"); // Жесткая привязка к FileLogger!
        logger.Log($"Processing order {order.Id}");

        // ... логика обработки ...

        // ПЛОХО: Создает валидатор "на лету". Почему здесь?
        var validator = new OrderValidator(); 
        if (!validator.Validate(order))
        {
            throw new Exception("Invalid order");
        }
    }
}
```

**Проблемы:**

- OrderProcessor знает конкретные реализации FileLogger и OrderValidator.
- Нельзя подменить логгер на ConsoleLogger или DatabaseLogger без изменения кода OrderProcessor.
- Нельзя подменить валидатор для тестов.
- Логика создания "размазана" внутри метода, нарушая SRP.
- Сложно понять истинные зависимости класса.

## 2. Антипаттерн: "Статическая Фабрика-Мусорка"

```csharp
public static class ObjectFactory
{
    public static ILogger CreateLogger() => new FileLogger("log.txt");
    public static IValidator CreateOrderValidator() => new OrderValidator();
    // ... и еще 20 методов создания всего подряд ...
}

public class OrderProcessor
{
    public void Process(Order order)
    {
        var logger = ObjectFactory.CreateLogger(); // Немного лучше, но...
        logger.Log($"Processing order {order.Id}");

        var validator = ObjectFactory.CreateOrderValidator();
        if (!validator.Validate(order)) { ... }
    }
}
```

**Проблемы:**
- Централизация без смысла. ObjectFactory становится "божественным" создателем всего.
- Нарушение Creator: Почему эта фабрика должна создавать OrderValidator? Какая у нее связь с заказами?
- Скрывает истинную сложность и зависимости. Тестирование OrderProcessor требует настройки глобальной фабрики.
- Все еще жесткая привязка к конкретным типам внутри фабрики (если не используется DI контейнер).

## 3. Правильное Применение Creator

### Пример 1: Агрегация / Композиция (Часть Целого)

```csharp
public class Order
{
    public int Id { get; }
    private List<OrderItem> _items = new List<OrderItem>(); // Order АГРЕГИРУЕТ OrderItem

    // Order - Creator для OrderItem: Он содержит/агрегирует их!
    public OrderItem AddItem(Product product, int quantity)
    {
        // Order обладает всей информацией (product, quantity) и смысловым правом!
        var newItem = new OrderItem(product, quantity); 
        _items.Add(newItem);
        return newItem;
    }
}

public class OrderItem
{
    public Product Product { get; }
    public int Quantity { get; }

    public OrderItem(Product product, int quantity) // Конструктор
    {
        Product = product;
        Quantity = quantity;
    }
}
```

**Почему Правильно:** Order логически владеет коллекцией OrderItem. Он знает, какие данные (Product, quantity) нужны для создания позиции. Создание OrderItem инкапсулировано внутри Order. Внешний код не создает OrderItem напрямую, а вызывает order.AddItem(...).

### Пример 2: Активное Использование + Обладание Данными (Сервисы)

```csharp
public class ReportGenerator
{
    private readonly IDataFetcher _dataFetcher; // ReportGenerator активно использует IDataFetcher

    // ReportGenerator - НЕ Creator для IDataFetcher! Он лишь его использует.
    // Кто создает IDataFetcher? См. ниже про DI.
    public ReportGenerator(IDataFetcher dataFetcher)
    {
        _dataFetcher = dataFetcher;
    }

    public Report GenerateComplexReport()
    {
        var data = _dataFetcher.FetchData();
        // ...

        // ReportGenerator СОЗДАЕТ Report? Да, если:
        // 1. Он активно его использует (это его основной результат).
        // 2. Он обладает данными (обработанный `data`) для его создания.
        var report = new Report(data, DateTime.UtcNow, "Complex Report"); 
        // ... возможная дополнительная настройка отчета ...
        return report;
    }
}
```

**Почему Правильно:** ReportGenerator логически производит Report. У него есть все необходимые данные после обработки. Он — естественный создатель конечного отчета.

## Creator и Dependency Injection (DI): Кто Главный?

**DI-контейнер — это механизм создания, но не архитектурное решение о том, кто должен быть ответственным за создание!** Creator говорит о логическом праве, DI — о технике реализации.

**Правильно:** Использовать DI для внедрения зависимостей, которые класс использует, но не создает по смыслу (не является их Creator'ом). Как IDataFetcher в ReportGenerator.

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Контейнер регистрирует КАК создавать IDataFetcher (техника)
        services.AddScoped<IDataFetcher, DatabaseFetcher>();
        services.AddScoped<ReportGenerator>(); // Контейнер создаст ReportGenerator, внедрив IDataFetcher
    }
}

// Использование (например, в контроллере):
public class ReportController : ControllerBase
{
    private readonly ReportGenerator _reportGenerator;

    // DI внедряет ReportGenerator (который кто-то создал - контейнер)
    public ReportController(ReportGenerator reportGenerator) 
    {
        _reportGenerator = reportGenerator;
    }

    [HttpGet("complex")]
    public Report GetComplexReport()
    {
        // ReportGenerator (Creator) создает отчет!
        return _reportGenerator.GenerateComplexReport(); 
    }
}
```

**Неправильно:** Злоупотреблять Service Locator (антипаттерн) внутри класса, чтобы вытаскивать зависимости, которые он должен был бы создавать сам по принципу Creator. Это скрывает зависимости и нарушает инкапсуляцию.

```csharp
// ПЛОХО: Service Locator внутри Order
public class Order
{
    public void CalculateTotal()
    {
        // Прячем зависимость. Теперь неявно, что Order нужен ILogger.
        var logger = ServiceLocator.Current.GetService<ILogger>(); 
        logger.Log("Calculating...");
        // ...
    }
}
```

## Когда Нарушать Creator? (Границы и Pure Fabrication)

1. **Сложное Создание (Abstract Factory):** Если создание объекта Б требует сложной логики (выбор реализации, конфигурация), которую нелепо помещать в A, используйте паттерн **Абстрактная Фабрика**. Это обоснованное нарушение, форма Pure Fabrication. Сама фабрика становится ответственной за создание.
2. **Создание Граничных Объектов (Infrastructure):** Объекты, связанные с инфраструктурой (например, DbContext в EF Core, HttpClient, FileStream), обычно **не создаются** бизнес-классами по Creator. Их создание делегируется:
- **Фреймворку** (ASP.NET Core создает DbContext для запроса).
- **Специализированным Фабрикам** (например, IHttpClientFactory).
- **Композиционному Корню** приложения.

Это делается для управления временем жизни, конфигурацией и изоляции инфраструктуры.

## Как Применять Creator

1. **Определите Класс Б:** Что нужно создать?
2. **Найдите Кандидата А:**
- Содержит ли какой-то класс коллекцию Б? (Агрегатор)
- Будет ли Б частью состояния другого объекта? (Композиция)
- Активно ли использует другой объект Б в своей работе? (Зависимость)
- Есть ли объект, владеющий данными для инициализации Б?
3. **Проверьте Связь:** Является ли связь А и Б сильной и семантически оправданной? Не создаст ли это нежелательной связанности?
4. **Реализуйте Создание:**
- **Прямое создание (new):** Если зависимость стабильна и не требует подмены (например, OrderItem внутри Order).
- **Фабричный Метод (protected virtual):** Если нужна гибкость в наследниках.
- **Внедрение Фабрики (DI):** Если создание сложное и требует абстракции (реализуйте интерфейс IOrderItemFactory и внедрите его в Order).
5. **Избегайте new для Сервисов:** Для зависимостей, которые класс использует (сервисы, репозитории, внешние клиенты), используйте DI. Пусть их созданием занимается композиционный корень или контейнер.

## Зачем Управлять Хаосом Создания?

**Принцип Creator** — это архитектурный сдерживающий фактор. Он предотвращает:
- **Размывание ответственности:** Классы не создают что попало.
- **Скрытые зависимости:** Связи new видны в конструкторах или методах создания.
- **Нетестируемость:** Жесткое создание зависимостей внутри методов ломает тесты.
- **Хрупкость:** Изменение способа создания объекта Б требует правок во всех местах, где его new-ят хаотично.

## Заключение

Принцип **Creator** дал нам не техническую инструкцию ("как создать?"), а **архитектурный мандат: "Кому разрешено создавать?"**. Это вопрос власти и ответственности в вашем коде.

1. **Создание – Это Отношения:** new – это не просто вызов конструктора. Это установление сильной семантической связи между создающим и создаваемым объектом. Отнеситесь к этому как к проектированию родственных уз в вашей объектной иерархии.
2. **Право Рождать - Это Логическая Близость:** Creator определяется не удобством, а естественными отношениями: владение (композиция), управление коллекцией (агрегация), активное использование, обладание ключевыми данными. Если этих связей нет – у класса нет права newить!
3. **Дикий new – Враг Архитектуры:** Хаотичное создание объектов где попало – прямой путь к:
- "Подпольным фабрикам" и "статическим помойкам", маскирующим зависимости.
- Жесткой связанности (High Coupling), когда замена реализации ломает пол-системы.
- Нетестируемости, из-за невозможности изолировать объект и подменить его зависимости.
- Нарушению инкапсуляции, когда классы лезут в чужие дела, чтобы что-то создать.
4. **DI - Это не Отмена Creator:** Dependency Injection – блестящий механизм для внедрения зависимостей, которые класс использует, но не создает по праву (не является их Creator'ом). Для истинных Creator'ов (как Order для OrderItem) new часто остается чистым и правильным выбором. DI управляет сервисами, Creator управляет семантикой владения.
5. **Фабрики – Легальные Нарушители:** Сложное создание (выбор реализации, конфигурация) – законная территория Абстрактных Фабрик (Abstract Factory). Это осознанное применение Pure Fabrication во имя практической пользы и соблюдения SRP.