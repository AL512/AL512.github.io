layout: default
title:  Pure Fabrication: Искусственные миры
parent: GRAPS
nav_order: 7
---
#  Pure Fabrication: Искусственные миры

*Когда нарушать ООП догмы ради практической пользы?*

Иногда строгое следование Information Expert или High Cohesion приводит к... проблемам. Логика размазывается, классы становятся слишком "умными" или, наоборот, слишком тупыми, нарушается Low Coupling. **Pure Fabrication (Чистая Выдумка) – это сознательное нарушение "естественности" ООП ради высших архитектурных целей.** Вы создаете "искусственный" класс или сервис, которому нет прямого аналога в предметной области, но который берет на себя ответственность для достижения лучшей связности, меньшей связанности или повторной используемости (например, EmailSender, ReportGenerator, Repository). Это сервисный слой, утилиты, DTO.

**Суть принципа:**

**Создайте "искусственный" класс, не имеющий аналога в предметной области, если это необходимо для:**
- Сохранения **High Cohesion** и **Low Coupling**
- Повторного использования кода
- Упрощения архитектуры

## Почему "Искусственные миры"?
Иногда строгое следование принципам ООП (вроде **Information Expert**) приводит к проблемам:

- Логика оказывается в неподходящем месте,
- Классы становятся перегруженными,
- Возникают нежелательные зависимости.

**Pure Fabrication** — это сознательное нарушение "естественности" модели ради высших архитектурных целей.

## Когда Нужно Создавать "Искусственный" Класс?

1. **Для сохранения Low Coupling:**

```csharp

    // Проблема: Order знает о способах доставки
    public class Order {
        public void CalculateShipping(ShipmentService shipService) { ... } // Прямая связь!
    }
    
    // Решение: Искусственный класс-посредник
    public class ShippingCalculator { // Pure Fabrication!
        public decimal Calculate(Order order, Address address) { ... }
    }
```

2. **Для обеспечения повторного использования:**

```csharp
    
    // Логика валидации email нужна в User, Order, Newsletter
    // Но "естественного" места для нее нет!
    
    public class EmailValidator { // Pure Fabrication!
        public static bool IsValid(string email) { ... }
    }
```

3. **Для работы с инфраструктурой:**
 
```csharp
    
    // Антипаттерн: User знает о базе данных
    public class User {
        public void Save() { 
            _dbContext.Users.Save(this); // Ужас!
        }
    }
    
    // Решение: Repository (классический Pure Fabrication)
    public class UserRepository { // Искусственный класс!
        public void Save(User user) { ... }
    }
```

## 5 Классических Примеров Pure Fabrication

### 1. Сервисы (Service Layer)

```csharp

// Нет в предметной области "сервиса отправки email"
public class EmailNotificationService { // Pure Fabrication!
    public void SendWelcomeEmail(User user) { ... }
}
```

### 2. DTO (Data Transfer Objects)

```csharp

// DTO не существует в домене — это искусственная конструкция
public class UserDto { 
    public string Name { get; set; }
    public string Email { get; set; }
}
```

### 3. Фабрики (Factories)

```csharp

// Фабрика — чистая выдумка для управления созданием
public class ReportFactory {
    public IReport Create(ReportType type) { ... }
}
```


### 4. Хелперы/Утилиты

```csharp

// MathUtils не существует в реальном мире
public static class MathUtils { // Pure Fabrication!
    public static double CalculateDistance(Point a, Point b) { ... }
}
```

### 5. Репозитории (Repository Pattern)

```csharp

// "Хранилища" — это искусственная абстракция над БД
public interface IUserRepository { // Pure Fabrication!
    User GetById(int id);
    void Save(User user);
}
```

## Как Отличить Хороший Pure Fabrication от Плохого?

**Хороший (оправданный):**

- Решает конкретную техническую проблему,
- Сохраняет или улучшает связность и зацепление,
- Не нарушает доменную логику.

**Плохой (неоправданный):**

- Дублирует функциональность существующих классов,
- Создает избыточную сложность,
- Служит костылем для плохой архитектуры.

## Антипаттерн: "Слепая Выдумка"

```csharp

// Неоправданный Pure Fabrication: класс не несет ценности
public class OrderProcessorHelper { // Что это вообще делает?
    public void ProcessOrder(Order order) { ... } // Дублирует OrderService?
}
```

**Правильный подход:**

```csharp

// Четкая ответственность
public class OrderTaxCalculator { // Ясно, что делает
    public decimal CalculateTax(Order order) { ... }
}
```


## Практическое Правило Применения

1. **Сначала пробуйте Information Expert:**
    - Можно ли поместить логику в существующий доменный объект
2. **Если нет — создавайте Pure Fabrication:**
    - Спросите: "Что будет проще тестировать и поддерживать?"
3. **Следите за балансом:**
    - Слишком много "искусственных" классов = сложность архитектуры


## Связь с Другими Принципами GRASP

- **Low Coupling:** Pure Fabrication часто вводится для уменьшения связей.
- **High Cohesion:** Помогает вынести несвязанную логику из доменных объектов.
- **Indirection:** Создает промежуточный слой между компонентами.


## Когда Выдумывать Миры Оправдано?

1. **Для инфраструктуры:** Работа с БД, внешними API, файловой системой.
2. **Для сквозной функциональности:** Логирование, кеширование, безопасность.
3. **Для утилитарных задач:** Математические расчеты, валидация данных.
4. **Для управления созданием объектов:** Фабрики, билдеры.

**Pure Fabrication — это мост между идеальной ООП-моделью и реальными потребностями разработки.**

**Ваш код не должен быть рабом догм — иногда лучшим решением будет создать искусственный класс, который спасет архитектуру от хаоса!**

## Заключение

**Pure Fabrication — это принцип-освободитель.** Он снимает оковы строгого следования предметной области и дает вам право создавать "искусственные" классы, которые спасают код от хаоса, даже если их нет на диаграмме предметной области.

**Главный вывод прост:**

**Если следование "естественным" принципам ООП (like Information Expert) ведет к плохой архитектуре (Low Cohesion, High Coupling) — вы имеете полное право выдумать новый класс, который эту архитектуру улучшит.**